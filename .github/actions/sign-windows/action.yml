name: 'Sign Windows Binaries with DigiCert KeyLocker'
description: 'Downloads, signs, and re-uploads Windows binaries using DigiCert KeyLocker (Software Trust Manager)'
inputs:
  version:
    description: 'Release version tag (e.g., "1.0.2", "canary")'
    required: true
  github-token:
    description: 'GitHub token for downloading/uploading release assets'
    required: true
  sm-api-key:
    description: 'DigiCert Software Trust Manager API key'
    required: true
  sm-host:
    description: 'DigiCert Software Trust Manager host URL'
    required: true
  sm-client-cert-file-b64:
    description: 'Base64-encoded DigiCert client certificate file'
    required: true
  sm-client-cert-password:
    description: 'Password for the DigiCert client certificate'
    required: true
  sm-code-signing-cert-sha1-hash:
    description: 'SHA1 hash/fingerprint of the code signing certificate in KeyLocker'
    required: true
  binary-pattern:
    description: 'Pattern to match Windows binaries (default: "bun-windows-*.zip")'
    required: false
    default: "bun-windows-*.zip"

runs:
  using: 'composite'
  steps:
    - name: Install DigiCert KeyLocker tools
      uses: digicert/ssm-code-signing@v1.0.0
      
    - name: Setup DigiCert client certificate
      shell: bash
      run: |
        echo "Setting up DigiCert client certificate..."
        echo "${{ inputs.sm-client-cert-file-b64 }}" | base64 --decode > /d/Certificate_pkcs12.p12
        echo "✓ Client certificate saved"
      
    - name: Configure DigiCert KeyLocker environment
      shell: bash
      run: |
        echo "Configuring DigiCert KeyLocker environment variables..."
        echo "SM_HOST=${{ inputs.sm-host }}" >> "$GITHUB_ENV"
        echo "SM_API_KEY=${{ inputs.sm-api-key }}" >> "$GITHUB_ENV"
        echo "SM_CLIENT_CERT_FILE=D:\\Certificate_pkcs12.p12" >> "$GITHUB_ENV"
        echo "SM_CLIENT_CERT_PASSWORD=${{ inputs.sm-client-cert-password }}" >> "$GITHUB_ENV"
        echo "✓ Environment configured"

    - name: Test DigiCert KeyLocker connection
      shell: cmd
      run: |
        echo Testing DigiCert KeyLocker connection...
        smctl healthcheck
        echo ✓ KeyLocker connection successful
        
        echo Listing available certificates...
        smctl keypair ls
        
    - name: Download Windows binaries
      shell: pwsh
      run: |
        Write-Host "Downloading Windows binaries for version: $env:VERSION"
        New-Item -ItemType Directory -Path "./temp-downloads" -Force
        
        # Use gh CLI to download Windows binaries
        gh release download "$env:VERSION" --pattern "$env:BINARY_PATTERN" --dir ./temp-downloads
        
        # List downloaded files
        $downloaded = Get-ChildItem -Path "./temp-downloads" -Filter "*.zip"
        Write-Host "Downloaded $($downloaded.Count) files:"
        foreach ($file in $downloaded) {
          Write-Host "  - $($file.Name) ($([math]::Round($file.Length / 1MB, 2)) MB)"
        }
        
        if ($downloaded.Count -eq 0) {
          Write-Error "No Windows binaries found for version $env:VERSION with pattern $env:BINARY_PATTERN"
          exit 1
        }
      env:
        VERSION: ${{ inputs.version }}
        BINARY_PATTERN: ${{ inputs.binary-pattern }}
        GITHUB_TOKEN: ${{ inputs.github-token }}

    - name: Extract and sign binaries with KeyLocker
      shell: pwsh
      run: |
        Write-Host "Extracting and signing Windows binaries with DigiCert KeyLocker..."
        
        # Create directories
        New-Item -ItemType Directory -Path "./extracted" -Force
        New-Item -ItemType Directory -Path "./signed-binaries" -Force
        
        $binaries = Get-ChildItem -Path "./temp-downloads" -Filter "*.zip"
        $certFingerprint = "$env:SM_CODE_SIGNING_CERT_SHA1_HASH"
        
        foreach ($binary in $binaries) {
          Write-Host ""
          Write-Host "=== Processing $($binary.Name) ==="
          
          # Extract the zip file
          $extractPath = "./extracted/$($binary.BaseName)"
          Write-Host "Extracting to: $extractPath"
          Expand-Archive -Path $binary.FullName -DestinationPath $extractPath -Force
          
          # Find all .exe files (should be bun.exe)
          $exeFiles = Get-ChildItem -Path $extractPath -Recurse -Filter "*.exe"
          Write-Host "Found $($exeFiles.Count) executable files:"
          
          foreach ($exe in $exeFiles) {
            Write-Host "  - $($exe.FullName)"
            
            # Sign the binary using DigiCert KeyLocker
            Write-Host "Signing $($exe.Name) with KeyLocker..."
            $signResult = cmd /c "smctl sign --fingerprint $certFingerprint --input `"$($exe.FullName)`" 2>&1"
            
            if ($LASTEXITCODE -ne 0) {
              Write-Error "Failed to sign $($exe.Name): $signResult"
              exit 1
            }
            
            Write-Host "Sign output: $signResult"
            
            # Verify the signature using signtool
            Write-Host "Verifying signature for $($exe.Name)..."
            $verifyResult = Start-Process -FilePath "signtool" -ArgumentList @("verify", "/pa", "/v", $exe.FullName) -Wait -PassThru -NoNewWindow -RedirectStandardOutput "./verify_output.txt" -RedirectStandardError "./verify_error.txt"
            
            if ($verifyResult.ExitCode -ne 0) {
              $verifyOutput = Get-Content "./verify_output.txt" -ErrorAction SilentlyContinue
              $verifyError = Get-Content "./verify_error.txt" -ErrorAction SilentlyContinue
              Write-Error "Signature verification failed for $($exe.Name): $verifyOutput $verifyError"
              exit 1
            }
            
            Write-Host "✓ Successfully signed and verified $($exe.Name)"
          }
          
          # Repackage the signed binary
          $signedZipPath = "./signed-binaries/$($binary.Name)"
          Write-Host "Repackaging to: $signedZipPath"
          Compress-Archive -Path "$extractPath/*" -DestinationPath $signedZipPath -Force
          
          Write-Host "✓ Created signed package: $($binary.Name)"
        }
        
        Write-Host ""
        Write-Host "=== Signing Summary ==="
        $signedFiles = Get-ChildItem -Path "./signed-binaries" -Filter "*.zip"
        Write-Host "Successfully signed $($signedFiles.Count) packages:"
        foreach ($file in $signedFiles) {
          Write-Host "  ✓ $($file.Name)"
        }
      env:
        SM_CODE_SIGNING_CERT_SHA1_HASH: ${{ inputs.sm-code-signing-cert-sha1-hash }}

    - name: Upload signed Windows binaries
      shell: pwsh
      run: |
        Write-Host "Uploading signed Windows binaries..."
        
        $signedBinaries = Get-ChildItem -Path "./signed-binaries" -Filter "*.zip"
        
        foreach ($binary in $signedBinaries) {
          Write-Host "Uploading: $($binary.Name)"
          gh release upload "$env:VERSION" "$($binary.FullName)" --clobber
          Write-Host "✓ Uploaded $($binary.Name)"
        }
        
        Write-Host ""
        Write-Host "=== Upload Complete ==="
        Write-Host "Successfully uploaded $($signedBinaries.Count) signed Windows binaries"
      env:
        VERSION: ${{ inputs.version }}
        GITHUB_TOKEN: ${{ inputs.github-token }}

    - name: Cleanup
      shell: pwsh
      run: |
        Write-Host "Cleaning up temporary files..."
        
        # Remove client certificate file
        $certPath = "D:\Certificate_pkcs12.p12"
        if (Test-Path $certPath) {
          Remove-Item $certPath -Force
          Write-Host "✓ Removed client certificate file"
        }
        
        # Remove working directories
        @("./temp-downloads", "./extracted", "./signed-binaries", "./verify_output.txt", "./verify_error.txt") | ForEach-Object {
          if (Test-Path $_) {
            Remove-Item $_ -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "✓ Removed $_"
          }
        }
        
        Write-Host "Cleanup complete"